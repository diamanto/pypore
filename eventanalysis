#!/usr/bin/env python
'''
This program is for finding events in files and displaying the results.
'''
import sys
from PyQt4 import QtGui, QtCore
import PyQt4.Qwt5 as Qwt
from DataFileOpener import openData
from scipy import fft, arange, signal
import numpy as np

class MyApp(QtGui.QMainWindow):
    
    def __init__(self, parent=None):
        super(MyApp, self).__init__()
        
        self.setWindowTitle('Translocation Event Analysis')
        
        self.create_menu()
        self.create_main_frame()
        self.create_status_bar()
        
        
    def initUI(self):      

        self.textEdit = QtGui.QTextEdit()
        self.setCentralWidget(self.textEdit)
        self.statusBar()

        openFile = QtGui.QAction(QtGui.QIcon('open.png'), 'Open', self)
        openFile.setShortcut('Ctrl+O')
        openFile.setStatusTip('Open New File')
        openFile.triggered.connect(self.showDialog)

        menubar = self.menuBar()
        fileMenu = menubar.addMenu('&File')
        fileMenu.addAction(openFile)       
        
#         self.setGeometry(300, 300, 350, 300)
        self.setWindowTitle('File dialog')
        self.show()
        
    def open_files(self):
        '''
        Opens file dialog box, adds names of files to open to list
        '''
        self.listWidget.clear()

        fnames = QtGui.QFileDialog.getOpenFileNames(self, 'Open file', 'data')
        print fnames
        for w in fnames:
            item = QtGui.QListWidgetItem(w)
            self.listWidget.addItem(item)
        
    def on_draw(self):
        print 'on_draw'
        
    def file_item_doubleclick(self, item):
        '''
        Open the file, parse data, then pass to plotData
        '''
        datadict = openData(str(item.text()))
        if not 'data' in datadict:
            print datadict
            return
#         self.axes_trace.clear()
#         self.plotData(datadict, self.axes_trace)

        self.plot.clear()
        self.plot.setAxisTitle(Qwt.QwtPlot.xBottom, 'x -->')
        self.plot.setAxisTitle(Qwt.QwtPlot.yLeft, 'y -->')
        data = datadict['data']
        sample_rate = datadict['SETUP_ADCSAMPLERATE']
        Ts = 1 / sample_rate
        n = len(data)
        plot_range = [0, n]
        print "size", n
        
        curve = Qwt.QwtPlotCurve("Current Trace")
        curve.setData(arange(Ts * plot_range[0], Ts * plot_range[1], Ts), data[plot_range[0]:plot_range[1]])
        curve.attach(self.plot)
        
        self.plot.replot()
        
        
        
    def create_main_frame(self):
        self.main_frame = QtGui.QWidget()
        
        # Create Qwt plot
        self.plot = Qwt.QwtPlot(self)
        self.plot.setCanvasBackground(QtCore.Qt.white)
        
        # Create a list for files want to analyze
        self.listWidget = QtGui.QListWidget()
        self.listWidget.itemDoubleClicked.connect(self.file_item_doubleclick)
        
        # Other GUI controls
        # 
        self.analyze_button = QtGui.QPushButton("&Analyze")
        self.connect(self.analyze_button, QtCore.SIGNAL('clicked()'), self.on_analyze)
        
        self.tab_widget = QtGui.QTabWidget()
        self.plot_event_zoomed = Qwt.QwtPlot(self)
        self.plot_event_zoomed.setCanvasBackground(QtCore.Qt.white)
        tab2 = QtGui.QWidget()
        
        # Create event zoom in in tab
        
        self.tab_widget.addTab(self.plot_event_zoomed, "Display Data")
        self.tab_widget.addTab(tab2, "Filter and Histogram")
        
        
        
        #
        # Layout with box sizers
        # 
        
        hbox = QtGui.QHBoxLayout()
        
        for w in [  self.analyze_button, ]:
            hbox.addWidget(w)
            hbox.setAlignment(w, QtCore.Qt.AlignVCenter)
        
        hbox_all = QtGui.QHBoxLayout()
        hbox_all.addLayout(hbox, 1)
        hbox_all.addWidget(self.plot, 3)
        
        vbox_all = QtGui.QVBoxLayout()
        vbox_all.addWidget(self.listWidget)
        vbox_all.addLayout(hbox_all)
        vbox_all.addWidget(self.tab_widget)
        
        self.main_frame.setLayout(vbox_all)
        self.setCentralWidget(self.main_frame)
        
        
    def create_status_bar(self):
        self.status_text = QtGui.QLabel("")
        self.statusBar().addWidget(self.status_text, 1)
    
    def create_menu(self):
        '''
        Creates File menu with Open
        '''
        self.file_menu = self.menuBar().addMenu("&File")
        
        load_file_action = self.create_action("&Open",
            shortcut="Ctrl+O", slot=self.open_files,
            tip="Open data Files")
        quit_action = self.create_action("&Quit", slot=self.close,
            shortcut="Ctrl+Q", tip="Close the application")
        
        self.add_actions(self.file_menu,
            (load_file_action, None, quit_action))
        
#         self.help_menu = self.menuBar().addMenu("&Help")
#         about_action = self.create_action("&About", 
#             shortcut='F1', slot=self.on_about, 
#             tip='About the demo')
#         
#         self.add_actions(self.help_menu, (about_action,))

    def add_actions(self, target, actions):
        for action in actions:
            if action is None:
                target.addSeparator()
            else:
                target.addAction(action)

    def create_action(self, text, slot=None, shortcut=None,
                        icon=None, tip=None, checkable=False,
                        signal="triggered()"):
        action = QtGui.QAction(text, self)
        if icon is not None:
            action.setIcon(QtGui.QIcon(":/%s.png" % icon))
        if shortcut is not None:
            action.setShortcut(shortcut)
        if tip is not None:
            action.setToolTip(tip)
            action.setStatusTip(tip)
        if slot is not None:
            self.connect(action, QtCore.SIGNAL(signal), slot)
        if checkable:
            action.setCheckable(True)
        return action
    
    def plotData(self, datadict, axes, plot_range='all'):
        '''
        Plots waveform in datadict
        pass in Data dictionary, with data at 'data' and sample rate at 'SETUP_ADCSAMPLERATE'
        Can pass in range as [start,stop], or 'all' for 0:n
        '''
        if axes is None:
            axes = self.axes_trace
        # Read the first file, store data in dictionary
        data = datadict['data']
        ADCSAMPLERATE = datadict['SETUP_ADCSAMPLERATE'][0][0]
    
        n = len(data)
        # If problem with input, just plot all the data
        if plot_range == 'all' or len(plot_range) != 2 or plot_range[1] <= plot_range[0]:
            plot_range = [0, n]
        else:  # no problems!
            n = plot_range[1] - plot_range[0]
    
        decimated = data[plot_range[0]:plot_range[1]]
        # Decimate the data if too many points, so matplotlib can still plot
        if n > 1000000:
            self.status_text.setText("Decimating Data")
            decimated = signal.decimate(data, int(len(data) / 1000000))
        Ts = 1 / ADCSAMPLERATE
        t = arange(Ts * plot_range[0], Ts * plot_range[1], Ts * n / len(decimated))
        
        self.status_text.setText("Plotting Data")
    
        # Ts = 1/ADCSAMPLERATE
        # t = arange(0,Ts*n,Ts*n/len(decimated))
        axes.plot(t[:n], decimated[:n])
        axes.set_xlabel('Time (s)')
        axes.set_ylabel('Current (nA)')
        
        self.canvas.draw()
        self.status_text.setText("Plotting done")
        
    def on_analyze(self):
        '''
        Searches for events in the file that is currently highlighted in the files list.
        '''
        currItem = self.listWidget.currentItem()
        if currItem == None:
            return
        
        datadict = openData(str(currItem.text()))
        if not 'data' in datadict:
            print datadict
            return

#         n = len(datadict['data'])
#         local_mean, local_stddev = self.local_mean_stddev(datadict['data'][0:n], 0.95)
#         self.axes_trace.clear()
#         self.plotData(datadict, self.axes_trace, [0, n])
#         datadict['data'] = local_mean
#         self.plotData(datadict, self.axes_trace, [0, n])
#         datadict['data'] = local_stddev
#         self.plotData(datadict, self.axes_event, [0, n])
        events = self.find_events(datadict)

    def local_mean_stddev(self, data, a=0.95):
        '''
        Does a recursive low-pass filter to estimate the mean and standard deviation at each point
        
        Returns an array of size len(data)
        '''
        local_mean = np.zeros(len(data))
        local_variance = np.zeros(len(data))
        local_mean[0] = data[0]
        local_variance[0] = 0.
        for i in range(1, len(data)):
            local_mean[i] = a * local_mean[i - 1] + (1 - a) * data[i]
            local_variance[i] = a * local_variance[i - 1] + (1 - a) * (data[i] - local_mean[i]) ** 2
        return local_mean, local_variance ** .5
    
    def find_events(self, datadict, threshold_type='adaptive', a=0.93,
                    threshold_direction='negative', min_event_length=10., max_event_length=1000.):
        '''
        Finds all the events in 'data'.
        
        Parameters: 
          datadict - must have data in 'data', sample rate in 'SETUP_ADCSAMPLERATE'
          threshold_type - 'adaptive' for adaptive-based threshold
                         - 'current' for current based TODO
          a - filter parameter for 'noise'. Should be close to 1, less than 1. nA for 'current'
          threshold_direction - 'positive' or 'negative'
          min_event_length - in microseconds
          max_event_length - in microseconds
          
        Returns:
          Struct containing all events found events
          
        '''
        data = datadict['data']
        sample_rate = datadict['SETUP_ADCSAMPLERATE'][0][0]
        timestep = 1 / sample_rate
        
        # Min and Max number of points in an event
        min_event_steps = int(min_event_length * 1e-6 / timestep)
        max_event_steps = int(max_event_length * 1e-6 / timestep)
        
        n = len(data)
        
        if n < 100:
            return 'Not enough datapoints in file.'
        
        local_mean = data[0]
        local_variance = 0.
        S = 5.  # Starting threshold parameter
        E = 1.  # Ending threshold parameter
        threshold = data[0]
        
        i = 100
        # initialize mean/variance with first x datapoints
        for k in range(1, i):
            local_mean = a * local_mean + (1 - a) * data[k]
            local_variance = a * local_variance + (1 - a) * (data[k] - local_mean) ** 2
            threshold = local_mean - S * local_variance ** .5
        
        i = 100
        event_count = 0
        # search for events.  Keep track of a filtered local (adapting!) mean and variance,
        # and use them to decide a threshold for events.  See
        # http://pubs.rsc.org/en/content/articlehtml/2012/nr/c2nr30951c for more details.
        while i < len(data):
            # could this be an event?
            event_start = 0
            event_end = 0
            # is event?
            if data[i] < threshold:
                # Set ending threshold
                threshold = local_mean - E * local_variance ** .5 
                event_start = i
                done = False
                event_i = i
                # loop until event ends
                while not done and (event_i) - event_start < max_event_steps:
                    if data[event_i] > threshold:
                        event_end = event_i
                        break
                    event_i = event_i + 1 
                if event_end - event_start > min_event_steps:
                    event_count = event_count + 1
                    print "Event ", event_count, ":", (event_end - event_start) / sample_rate, "s"
                    i = event_end
                    if i == 0:
                        i = i + max_event_length
                    self.axes_event.clear()
                    self.plotData(datadict, axes=self.axes_event, plot_range=[event_start - 50, event_end + 50])
                    self.plotData(datadict, axes=self.axes_event, plot_range=[event_start, event_end])
                    self.plotData(datadict, axes=self.axes_trace, plot_range=[event_start - 50, event_end + 50])
                    QtGui.QApplication.processEvents()
            local_mean = a * local_mean + (1 - a) * data[i]
            local_variance = a * local_variance + (1 - a) * (data[i] - local_mean) ** 2
            threshold = local_mean - S * local_variance ** .5 
            i = i + 1
            
        print "Number of events:", event_count
        
        
def plotSpectrum(data, rate):
    n = len(data)
    k = np.arange(n)
    T = n / rate
    frq = k / T  # Two sides frequency range
    frq = frq[range(n / 2)]  # one side frequency range
    
    Y = fft(data) / n  # fft and normalization
    Y = Y[range(n / 2)]
    
    decimated = frq
    if len(frq) > 1000000:
        decimated = signal.decimate(Y, int(len(data) / 1000000))
    t = arange(frq[0], frq[len(frq) - 1], (frq[len(frq) - 1] - frq[0]) / len(decimated))
    
    plt.plot(t, decimated, 'r')
    plt.xlim([frq[0], frq[n / 2 - 1]])
    plt.xlabel('Freq (Hz)')
    plt.ylabel('|Y(freq)|')


def main():
    
    app = QtGui.QApplication(sys.argv)
    ex = MyApp()
    ex.show()
    app.exec_()
    sys.exit()


if __name__ == '__main__':
    main()

