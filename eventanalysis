#!/usr/bin/env python
'''
This program is for finding events in files and displaying the results.
'''
import sys
from PyQt4 import QtGui, QtCore, Qt
import PyQt4.Qwt5 as Qwt
from DataFileOpener import openData
from scipy import fft, arange, signal
import scipy.io as sio


class PlotThread(QtCore.QThread):
    def __init__(self, axes, datadict = '', plot_range='all', filename = '', 
                 threshold_type='adaptive', a=0.93, 
                 threshold_direction='negative', min_event_length=10., max_event_length=1000.):
        QtCore.QThread.__init__(self)
        self.plot_options = {'axes': axes, 'datadict': datadict, 'plot_range': plot_range}
        self.filename = filename
        self.threshold_type = threshold_type
        self.a = a
        self.threshold_direction = threshold_direction
        self.min_event_length = min_event_length
        self.max_event_length = max_event_length
    
    def __del__(self):
        '''
        If the object instantiating this thread gets deleted, the thread will be deleted, causing
        a segfault, unless we implement this destructor.
        '''
        self.wait()
    
    def run(self):
        if not self.filename == '' or self.plot_options['datadict'] == '':
            self.plot_options['datadict'] = openData(self.filename)
        self.emit(QtCore.SIGNAL('plotData(PyQt_PyObject)'), {'plot_options': self.plot_options, 'status_text': ''})
        

class AnalyzeDataThread(QtCore.QThread):
    '''
    Class for searching for events in a separate thread.  
    '''
    def __init__(self, axes, filename = '',threshold_type='adaptive', a=0.93, 
                 threshold_direction='negative', min_event_length=10., max_event_length=1000.):
        QtCore.QThread.__init__(self)
        self.plot_options = {'axes': axes}
        self.filename = filename
        self.threshold_type = threshold_type
        self.a = a
        self.threshold_direction = threshold_direction
        self.min_event_length = min_event_length
        self.max_event_length = max_event_length
    
    def __del__(self):
        '''
        If the object instantiating this thread gets deleted, the thread will be deleted, causing
        a segfault, unless we implement this destructor.
        '''
        self.wait()
    
    def run(self):
        '''
        Finds all the events in 'data'.
        
        Parameters: 
          datadict - must have data in 'data', sample rate in 'SETUP_ADCSAMPLERATE'
          threshold_type - 'adaptive' for adaptive-based threshold
                         - 'current' for current based TODO
          a - filter parameter for 'noise'. Should be close to 1, less than 1. nA for 'current'
          threshold_direction - 'positive' or 'negative'
          min_event_length - in microseconds
          max_event_length - in microseconds
          
        Returns:
          Struct containing all events found events
          
        '''
        if not self.filename == '' or self.plot_options['datadict'] == '':
            self.plot_options['datadict'] = openData(self.filename)
        data = self.plot_options['datadict']['data']
        sample_rate = self.plot_options['datadict']['SETUP_ADCSAMPLERATE'][0][0]
        timestep = 1 / sample_rate
        
        # Min and Max number of points in an event
        self.min_event_steps = int(self.min_event_length * 1e-6 / timestep)
        self.max_event_steps = int(self.max_event_length * 1e-6 / timestep)
        
        n = len(data)
        
        if n < 100:
            return 'Not enough datapoints in file.'
        
        local_mean = data[0]
        local_variance = 0.
        S = 5.  # Starting threshold parameter
        E = 1.  # Ending threshold parameter
        threshold = data[0]
        
        i = 100
        # initialize mean/variance with first i datapoints
        for k in range(0, i):
            local_mean = self.a * local_mean + (1 - self.a) * data[k]
            local_variance = self.a * local_variance + (1 - self.a) * (data[k] - local_mean) ** 2
            threshold = local_mean - S * local_variance ** .5
        
        save_file = {}
        save_file['Events'] = []
        
        i = 100
        n = len(data)
        event_count = 0
        # search for events.  Keep track of a filtered local (adapting!) mean and variance,
        # and use them to decide a threshold for events.  See
        # http://pubs.rsc.org/en/content/articlehtml/2012/nr/c2nr30951c for more details.
        while i < n:
            # could this be an event?
            event_start = 0
            event_end = 0
            # is event?
            if data[i] < threshold:
                # Set ending threshold
                threshold = local_mean - E * local_variance ** .5 
                event_start = i
                done = False
                event_i = i
                # loop until event ends
                while not done and (event_i) - event_start < self.max_event_steps:
                    if data[event_i] > threshold:
                        event_end = event_i - 1
                        break
                    event_i = event_i + 1 
                # is the event long enough?
                if event_end - event_start > self.min_event_steps:
                    i = event_end
                    if i == 0:
                        i = i + self.max_event_length
                    self.plot_options['plot_range'] = [event_start - 50, event_end + 50]
                    self.emit(QtCore.SIGNAL('_analyze_data_thread_callback(PyQt_PyObject)'), {'plot_options': self.plot_options})
                    save_file['Events'].append({})
                    save_file['Events'][event_count]['event_data'] = data[event_start:event_end]
                    save_file['Events'][event_count]['raw_data'] = data[event_start-50 : event_end + 50]
                    save_file['Events'][event_count]['baseline'] = local_mean
                    event_count = event_count + 1
            local_mean = self.a * local_mean + (1 - self.a) * data[i]
            local_variance = self.a * local_variance + (1 - self.a) * (data[i] - local_mean) ** 2
            threshold = local_mean - S * local_variance ** .5 
            i = i + 1
            if i % 50000 == 0:
                self.emit(QtCore.SIGNAL('_analyze_data_thread_callback(PyQt_PyObject)'), {'status_text': 'Event Count: ' + str(event_count) + ' Percent Done: ' + str(100.*i/n)})
                
        if event_count > 0:
            save_file_name = list(self.filename)
            # Remove the .mat off the end
            for i in range(0,4):
                save_file_name.pop()
                
            save_file_name.append('_Events.mat')
            save_file['filename'] = "".join(save_file_name)
            save_file['sample_rate'] = sample_rate
            save_file['event_count'] = event_count
            sio.savemat(save_file['filename'], save_file)
            
        self.emit(QtCore.SIGNAL('_analyze_data_thread_callback(PyQt_PyObject)'), {'status_text': 'Done. Found ' + str(event_count) + ' events.'})  
  
    
class MyApp(QtGui.QMainWindow):
    
    def __init__(self, parent=None):
        super(MyApp, self).__init__()
        
        self.threadPool = []
        
        self.setWindowTitle('Translocation Event Analysis')
        
        self.create_menu()
        self.create_main_frame()
        self.create_status_bar()
        
        self.__initZooming()
#         self.showMaximized()
        
    def __initZooming(self):
        """Initialize zooming
        """

        self.zoomer = Qwt.QwtPlotZoomer(Qwt.QwtPlot.xBottom,
                                        Qwt.QwtPlot.yLeft,
                                        Qwt.QwtPicker.DragSelection,
                                        Qwt.QwtPicker.AlwaysOff,
                                        self.plot.canvas())
        self.zoomer.setRubberBandPen(Qt.QPen(Qt.Qt.black))
        
    def open_files(self):
        '''
        Opens file dialog box, adds names of files to open to list
        '''
        self.listWidget.clear()

        fnames = QtGui.QFileDialog.getOpenFileNames(self, 'Open file', 'data')
        for w in fnames:
            item = QtGui.QListWidgetItem(w)
            self.listWidget.addItem(item)
        
    def _on_file_item_doubleclick(self, item):
        '''
        Called when a file list item is double clicked.
        Starts the plotting thread, which opens the file, parses data, then passes to plotData
        '''
        # adding by emitting signal in different thread
        self.status_text.setText('Plotting...')
        self.threadPool.append( PlotThread(self.plot, filename=str(item.text())) )
        self.connect( self.threadPool[len(self.threadPool)-1], QtCore.SIGNAL('plotData(PyQt_PyObject)'), self._on_file_item_doubleclick_callback )
        self.threadPool[len(self.threadPool)-1].start()
        
    def _on_file_item_doubleclick_callback(self, results):
        if 'plot_options' in results:
            self.plotData(results['plot_options'])
        if 'status_text' in results:
            self.status_text.setText(results['status_text'])
        
        
    def create_main_frame(self):
        '''
        Initializes the main gui frame.
        '''
        self.main_frame = QtGui.QWidget()
        
        # Put everything in a scroll area
        scrollArea = QtGui.QScrollArea()
        scrollArea.setWidgetResizable(True)
        
        # Create Qwt plot
        self.plot = Qwt.QwtPlot(self)
        self.plot.setCanvasBackground(QtCore.Qt.white)
        self.plot.setMinimumSize(400, 200)
        self.plot.setAxisTitle(Qwt.QwtPlot.xBottom, 'Time')
        self.plot.setAxisTitle(Qwt.QwtPlot.yLeft, 'Current')
        
        # Create a list for files want to analyze
        self.listWidget = QtGui.QListWidget()
        self.listWidget.itemDoubleClicked.connect(self._on_file_item_doubleclick)
        self.listWidget.setMaximumHeight(40)
        
        # Other GUI controls
        # 
        self.analyze_button = QtGui.QPushButton("&Analyze")
        self.connect(self.analyze_button, QtCore.SIGNAL('clicked()'), self.on_analyze)
        
        self.tab_widget = QtGui.QTabWidget()
        self.tab_widget.setMinimumSize(450, 250)
        self.plot_event_zoomed = Qwt.QwtPlot(self)
        self.plot_event_zoomed.setCanvasBackground(QtCore.Qt.white)
        self.plot_event_zoomed.setAxisTitle(Qwt.QwtPlot.xBottom, 'Time')
        self.plot_event_zoomed.setAxisTitle(Qwt.QwtPlot.yLeft, 'Current')
        tab2 = QtGui.QWidget()
        
        # Create event zoom in in tab
        
        self.tab_widget.addTab(self.plot_event_zoomed, "Display Data")
        self.tab_widget.addTab(tab2, "Filter and Histogram")
        
        
        
        #
        # Layout with box sizers
        # 
        
        filesLabel = QtGui.QLabel()
        filesLabel.setText('Files:')
        
        hboxfiles = QtGui.QHBoxLayout()
        hboxfiles.addWidget(filesLabel)
        hboxfiles.addWidget(self.listWidget)
        
        hbox = QtGui.QHBoxLayout()
        
        for w in [  self.analyze_button, ]:
            hbox.addWidget(w)
            hbox.setAlignment(w, QtCore.Qt.AlignVCenter)
        
        hbox_all = QtGui.QHBoxLayout()
        hbox_all.addLayout(hbox, 1)
        hbox_all.addWidget(self.plot, 3)
        
        vbox_all = QtGui.QVBoxLayout()
        vbox_all.addLayout(hboxfiles)
        vbox_all.addLayout(hbox_all)
        vbox_all.addWidget(self.tab_widget)
        
        self.main_frame.setLayout(vbox_all)
        scrollArea.setWidget(self.main_frame)
        self.setCentralWidget(scrollArea)
        
        
    def create_status_bar(self):
        '''
        Creates a status bar with a text widget.
        '''
        self.status_text = QtGui.QLabel("")
        self.statusBar().addWidget(self.status_text, 1)
    
    def create_menu(self):
        '''
        Creates File menu with Open
        '''
        self.file_menu = self.menuBar().addMenu("&File")
        
        load_file_action = self.create_action("&Open",
            shortcut="Ctrl+O", slot=self.open_files,
            tip="Open data Files")
        quit_action = self.create_action("&Quit", slot=self.close,
            shortcut="Ctrl+Q", tip="Close the application")
        
        self.add_actions(self.file_menu,
            (load_file_action, None, quit_action))
        
#         self.help_menu = self.menuBar().addMenu("&Help")
#         about_action = self.create_action("&About", 
#             shortcut='F1', slot=self.on_about, 
#             tip='About the demo')
#         
#         self.add_actions(self.help_menu, (about_action,))

    def add_actions(self, target, actions):
        for action in actions:
            if action is None:
                target.addSeparator()
            else:
                target.addAction(action)

    def create_action(self, text, slot=None, shortcut=None,
                        icon=None, tip=None, checkable=False,
                        signal="triggered()"):
        action = QtGui.QAction(text, self)
        if icon is not None:
            action.setIcon(QtGui.QIcon(":/%s.png" % icon))
        if shortcut is not None:
            action.setShortcut(shortcut)
        if tip is not None:
            action.setToolTip(tip)
            action.setStatusTip(tip)
        if slot is not None:
            self.connect(action, QtCore.SIGNAL(signal), slot)
        if checkable:
            action.setCheckable(True)
        return action
    
#     def plotData(self, data, axes, plot_range='all'):
    def plotData(self, plot_options):
        '''
        Plots waveform in datadict
        Pass in plot_options, a dictionary with 'plot_range', 'axes', and 'datadict'
        pass in Data dictionary, with data at 'data' and sample rate at 'SETUP_ADCSAMPLERATE'
        Can pass in range as [start,stop], or 'all' for 0:n
        '''
        axes = plot_options['axes']
        if axes is None:
            axes = self.plot
        # Read the first file, store data in dictionary
        data = plot_options['datadict']['data']
        sample_rate = plot_options['datadict']['SETUP_ADCSAMPLERATE'][0][0]
        plot_range = plot_options['plot_range']
    
        n = len(data)
#         # If problem with input, just plot all the data
        if plot_range == 'all' or len(plot_range) != 2 or plot_range[1] <= plot_range[0]:
            plot_range = [0, n]
        else:  # no problems!
            n = plot_range[1] - plot_range[0]
    
        axes.clear()
        Ts = 1 / sample_rate
        
        times = arange(Ts * plot_range[0], Ts * plot_range[1], Ts)
        
        curve = Qwt.QwtPlotCurve("Current Trace")
        curve.setData(times, data[plot_range[0]:plot_range[1]])
        curve.attach(axes)
        axes.replot()
        # Set the top of the zoom stack to current plot, if wanted.  False means no replot (we just plotted it!)
        if 'set_zoom_base' in plot_options:
            if plot_options['set_zoom_base'] == True:
                self.zoomer.setZoomBase(False)
        else:
            self.zoomer.setZoomBase(False)
        
    def on_analyze(self):
        '''
        Searches for events in the file that is currently highlighted in the files list.
        '''
        currItem = self.listWidget.currentItem()
        if currItem == None:
            return
        # Start analyzing data in new thread.
        self.threadPool.append( AnalyzeDataThread(self.plot_event_zoomed, str(currItem.text())))
        self.connect( self.threadPool[len(self.threadPool)-1], QtCore.SIGNAL('_analyze_data_thread_callback(PyQt_PyObject)'), self._analyze_data_thread_callback )
        self.threadPool[len(self.threadPool)-1].start()
        
    def _analyze_data_thread_callback(self, results):
        if 'plot_options' in results:
            self.plotData(results['plot_options'])
        if 'status_text' in results:
            self.status_text.setText(results['status_text'])
        
# def plotSpectrum(data, rate):
#     n = len(data)
#     k = np.arange(n)
#     T = n / rate
#     frq = k / T  # Two sides frequency range
#     frq = frq[range(n / 2)]  # one side frequency range
#     
#     Y = fft(data) / n  # fft and normalization
#     Y = Y[range(n / 2)]
#     
#     decimated = frq
#     if len(frq) > 1000000:
#         decimated = signal.decimate(Y, int(len(data) / 1000000))
#     t = arange(frq[0], frq[len(frq) - 1], (frq[len(frq) - 1] - frq[0]) / len(decimated))
#     
#     plt.plot(t, decimated, 'r')
#     plt.xlim([frq[0], frq[n / 2 - 1]])
#     plt.xlabel('Freq (Hz)')
#     plt.ylabel('|Y(freq)|')


def main():
    
    app = QtGui.QApplication(sys.argv)
    ex = MyApp()
    ex.show()
    app.exec_()
    sys.exit()


if __name__ == '__main__':
    main()

