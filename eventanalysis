#!/usr/bin/env python
'''
This program is for finding events in files and displaying the results.
'''
import sys
from PyQt4 import QtGui, QtCore
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as NavigationToolbar
from DataFileOpener import openData
from scipy import fft, arange, signal
import numpy as np
import matplotlib.pyplot as plt

class MyApp(QtGui.QMainWindow):
    
    def __init__(self, parent=None):
        super(MyApp, self).__init__()
        
        self.setWindowTitle('Translocation Event Analysis')
        
        self.create_menu()
        self.create_main_frame()
        self.create_status_bar()
        
        
    def initUI(self):      

        self.textEdit = QtGui.QTextEdit()
        self.setCentralWidget(self.textEdit)
        self.statusBar()

        openFile = QtGui.QAction(QtGui.QIcon('open.png'), 'Open', self)
        openFile.setShortcut('Ctrl+O')
        openFile.setStatusTip('Open new File')
        openFile.triggered.connect(self.showDialog)

        menubar = self.menuBar()
        fileMenu = menubar.addMenu('&File')
        fileMenu.addAction(openFile)       
        
        self.setGeometry(300, 300, 350, 300)
        self.setWindowTitle('File dialog')
        self.show()
        
    def open_files(self):
        '''
        Opens file dialog box, adds names of files to open to list
        '''
        self.listWidget.clear()

        fnames = QtGui.QFileDialog.getOpenFileNames(self, 'Open file', 'data')
        print fnames
        for w in fnames:
            item = QtGui.QListWidgetItem(w)
            self.listWidget.addItem(item)
        
    def on_draw(self):
        print 'on_draw'
        
    def file_item_doubleclick(self, item):
        '''
        Open the file, parse data, then pass to plotData
        '''
        datadict = openData(str(item.text()))
        if not 'data' in datadict:
            print datadict
            return
        self.plotData(datadict)
        
    def create_main_frame(self):
        self.main_frame = QtGui.QWidget()
        
        # Create the mpl Figure and FigCanvas objects. 
        # 5x4 inches, 100 dots-per-inch
        #
        self.dpi = 100
        self.fig = plt.Figure((6.0, 5.0), dpi=self.dpi)
        self.canvas = FigureCanvas(self.fig)
        
        # Create a list for files want to analyze
        self.listWidget = QtGui.QListWidget()
        self.listWidget.itemDoubleClicked.connect(self.file_item_doubleclick)
        
        # Since we have only one plot, we can use add_axes 
        # instead of add_subplot, but then the subplot
        # configuration tool in the navigation toolbar wouldn't
        # work.
        #
        self.axes = self.fig.add_subplot(111)
        
        # Create the navigation toolbar, tied to the canvas
        #
        self.mpl_toolbar = NavigationToolbar(self.canvas, self.main_frame)
        
        # Other GUI controls
        # 
        self.textbox = QtGui.QLineEdit()
        self.textbox.setMinimumWidth(200)
        self.connect(self.textbox, QtCore.SIGNAL('editingFinished ()'), self.on_draw)
        
        self.analyze_button = QtGui.QPushButton("&Analyze")
        self.connect(self.analyze_button, QtCore.SIGNAL('clicked()'), self.on_analyze)
        
        self.grid_cb = QtGui.QCheckBox("Show &Grid")
        self.grid_cb.setChecked(False)
        self.connect(self.grid_cb, QtCore.SIGNAL('stateChanged(int)'), self.on_draw)
        
        #
        # Layout with box sizers
        # 
        hbox = QtGui.QHBoxLayout()
        
        for w in [  self.textbox, self.analyze_button, self.grid_cb, ]:
            hbox.addWidget(w)
            hbox.setAlignment(w, QtCore.Qt.AlignVCenter)
        
        vbox = QtGui.QVBoxLayout()
        vbox.addWidget(self.canvas)
        vbox.addWidget(self.mpl_toolbar)
        vbox.addLayout(hbox)
        vbox.addWidget(self.listWidget)
        
        self.main_frame.setLayout(vbox)
        self.setCentralWidget(self.main_frame)
        
        
    def create_status_bar(self):
        self.status_text = QtGui.QLabel("Status")
        self.statusBar().addWidget(self.status_text, 1)
    
    def create_menu(self):
        '''
        Creates File menu with Open
        '''
        self.file_menu = self.menuBar().addMenu("&File")
        
        load_file_action = self.create_action("&Open",
            shortcut="Ctrl+O", slot=self.open_files,
            tip="Open data Files")
        quit_action = self.create_action("&Quit", slot=self.close,
            shortcut="Ctrl+Q", tip="Close the application")
        
        self.add_actions(self.file_menu,
            (load_file_action, None, quit_action))
        
#         self.help_menu = self.menuBar().addMenu("&Help")
#         about_action = self.create_action("&About", 
#             shortcut='F1', slot=self.on_about, 
#             tip='About the demo')
#         
#         self.add_actions(self.help_menu, (about_action,))

    def add_actions(self, target, actions):
        for action in actions:
            if action is None:
                target.addSeparator()
            else:
                target.addAction(action)

    def create_action(self, text, slot=None, shortcut=None,
                        icon=None, tip=None, checkable=False,
                        signal="triggered()"):
        action = QtGui.QAction(text, self)
        if icon is not None:
            action.setIcon(QtGui.QIcon(":/%s.png" % icon))
        if shortcut is not None:
            action.setShortcut(shortcut)
        if tip is not None:
            action.setToolTip(tip)
            action.setStatusTip(tip)
        if slot is not None:
            self.connect(action, QtCore.SIGNAL(signal), slot)
        if checkable:
            action.setCheckable(True)
        return action
    
    def plotData(self, datadict, plot_range = 'all'):
        '''
        Plots waveform in datadict
        pass in Data dictionary, with data at 'data' and sample rate at 'SETUP_ADCSAMPLERATE'
        Can pass in range as [start,stop], or 'all' for 0:n
        '''
        self.axes.clear()
        # Read the first file, store data in dictionary
        data = datadict['data']
        ADCSAMPLERATE = datadict['SETUP_ADCSAMPLERATE'][0][0]
    
        n = len(data)
        if plot_range == 'all' or len(plot_range) != 2:
            plot_range = [0,n]
    
        decimated = data
        # Decimate the data if too many points, so matplotlib can still plot
        if n > 1000000:
            decimated = signal.decimate(data, int(len(data) / 1000000))
        Ts = 1 / ADCSAMPLERATE
        t = arange(0, Ts * n, Ts * n / len(decimated))
        print len(data), len(decimated[0:n - 1]), len(t)
    
        # Ts = 1/ADCSAMPLERATE
        # t = arange(0,Ts*n,Ts*n/len(decimated))
        self.axes.plot(t[plot_range[0]:plot_range[1]], decimated[plot_range[0]:plot_range[1]])
        self.axes.set_xlabel('Time (s)')
        self.axes.set_ylabel('Current (nA)')
        
        self.canvas.draw()
        
    def on_analyze(self):
        '''
        Searches for events in the file that is currently highlighted in the files list.
        '''
        currItem = self.listWidget.currentItem()
        if currItem == None:
            return
        
        datadict = openData(str(currItem.text()))
        if not 'data' in datadict:
            print datadict
            return
        
        events = self.find_events(datadict)
        
    def find_events(self, datadict, threshold_type='noise', threshold_level=1.,
                    threshold_direction='negative', min_event_length=10., max_event_length=1000.):
        '''
        Finds all the events in 'data'.
        
        Parameters: 
          datadict - must have data in 'data', sample rate in 'SETUP_ADCSAMPLERATE'
          threshold_type - 'noise' for noise-based threshold
                         - 'current' for current based 
          threshold_level - std deviations for 'noise', nA for 'current'
          threshold_direction - 'positive' or 'negative'
          min_event_length - in microseconds
          max_event_length - in microseconds
          
        Returns:
          Struct containing all events found events
          
        '''
        data = datadict['data']
        sample_rate = datadict['SETUP_ADCSAMPLERATE'][0][0]
        timestep = 1 / sample_rate
        
        # Min and Max number of points in an event
        min_event_steps = int(min_event_length * 1e-6 / timestep)
        max_event_steps = int(max_event_length * 1e-6 / timestep)
        
        n = len(data)
        
        if n < 100:
            return 'Not enough datapoints in file.'
        
        i = int(min_event_steps/2)
        
        look_step = int(min_event_steps/2)
        
        negpos = -1
        if not threshold_direction == 'negative':
            negpos = 1 
            
        count = 0
        
        while i < n-max_event_steps/2:
            background = data[i-look_step:i]
            background_mean = np.mean(background)
            background_std = np.std(background)
            
            x = np.mean(data[i-3:i+3]) - negpos*np.std(data[i-3:i+3])
            y = background_mean + negpos*background_std
            if negpos*(y-x) < 0:
                count = count+1
                self.plotData(datadict, [i-max_event_length, i+max_event_length])
                raw_input('Press ENTER to continue')
            
            print 1.0*i/n, count
            i = i+look_step
        
        print count
        # TODO
        return

def plotSpectrum(data, rate):
    n = len(data)
    k = np.arange(n)
    T = n / rate
    frq = k / T  # Two sides frequency range
    frq = frq[range(n / 2)]  # one side frequency range
    
    Y = fft(data) / n  # fft and normalization
    Y = Y[range(n / 2)]
    
    decimated = frq
    if len(frq) > 1000000:
        decimated = signal.decimate(Y, int(len(data) / 1000000))
    t = arange(frq[0], frq[len(frq) - 1], (frq[len(frq) - 1] - frq[0]) / len(decimated))
    
    plt.plot(t, decimated, 'r')
    plt.xlim([frq[0], frq[n / 2 - 1]])
    plt.xlabel('Freq (Hz)')
    plt.ylabel('|Y(freq)|')


def main():
    
    app = QtGui.QApplication(sys.argv)
    ex = MyApp()
    ex.show()
    app.exec_()
    sys.exit()


if __name__ == '__main__':
    main()

